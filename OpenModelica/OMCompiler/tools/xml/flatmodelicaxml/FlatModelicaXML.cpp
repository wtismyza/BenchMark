/* Copyright (c)2000 Linköping University Sweden, All Rights Reserved
/* Programming Environments Laboratory
*******************************************************************************
  File        : "FlatModelicaXML.cpp"
  Author      : Adrian Pop 2005-05-26
  Description : Antlr Parser caller and XML serializer for Flat Modelica
-------------------------------------------------------------------------------
  Source:
  Revision:
  Author:  Adrian Pop
  Date:    2004-05-26
*******************************************************************************
*/


//**  HEADERS ************************************************************

// standard include files
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <fstream>

// ModelicaParser related include file
// the following header files are automatically generated by the antlr parser (Do not modify them)
#include "Flat_Modelica_Lexer.hpp"
#include "Flat_Modelica_Parser.hpp"
#include "Flat_Modelica_Tree_Parser.hpp"
#include "Flat_Modelica_ParserTokenTypes.hpp"
#include "Flat_Modelica_Tree_ParserTokenTypes.hpp"
#include "parse_tree_dumper.hpp"

// antlr related include files
#include "antlr/AST.hpp"
#include "antlr/CommonAST.hpp"
#include "antlr/ASTFactory.hpp"
#include "MyAST.h"


using namespace std;

//-----------------------------------------------------------------------------
// func         : main function for the modelica optimizer
// author       : Adrian Pop 2003-10-25
// organization : Linköping University Sweden, Programming Environment Laboratory
//-----------------------------------------------------------------------------
// the function accept as argument a flattened modelica file ad will generate as output the corresponding C files
// for the Modelica Simulator
int main( int argc, char* argv[] )
{
  ifstream file;
  //ofstream wfile;

  // check if the modelica file is present in the argument list
    if (argc < 2)
  {
      cerr << "Incorrect number of arguments\n";
      return 1;
    }

  //open the file passed as an argument
    file.open(argv[1]);

  //if the file cannot be opened
    if (!file)
  {
      cerr << "Could not open file: " << argv[1] << "\n";
    getchar();
      return 2;
    }

    try
  {
    antlr::ASTFactory my_factory("MyAST", MyAST::factory);
    flat_modelica_lexer lexer(file);
    lexer.setFilename(argv[1]);
    flat_modelica_parser parser(lexer);
    parser.initializeASTFactory(my_factory);
    parser.setASTFactory(&my_factory);
    parser.stored_definition();
    //wfile.open("output.txt");
    //wfile << parser.getAST()->toStringList() << std::endl;
    antlr::RefAST ast = parser.getAST();
    //parse_tree_dumper dumper(std::cout);
    std::cout << std::flush;
    if (ast)
    {
        //dumper.dump(ast);
        flat_modelica_tree_parser walker;
      walker.initializeASTFactory(my_factory);
      walker.setASTFactory(&my_factory);
      std::string xmlFile(argv[1]);
      /*
      http://www.ida.liu.se/~adrpo/modelica/xml/modelicaxml-v2.dtd
      c:\\dev\\src\\modelicaxml\\modelicaxml-v2.dtd
      */
      // set the doctype
      std::string docType(
        (argc > 2)?argv[2]:"http://www.ida.liu.se/~adrpo/modelica/xml/modelicaxml-v2.dtd");
      xmlFile += ".xml";
      walker.stored_definition(
        RefMyAST(ast),
        xmlFile,
        argv[1],
        docType);
    }
    else
    {
      //wfile << std::endl << "Parse error: <NULL> AST\n";
      std::cerr << std::endl << "Parse error: <NULL> AST\n";
    }
  }
    catch(antlr::ANTLRException& e)
  {
    std::cerr << "Parser/Lexer/Walker Exception: " << e.toString() << std::endl;
    file.close();
    std::cerr << "ERROR! File:" << argv[1] << std::endl;
    getchar();
    return EXIT_FAILURE;
  }
    catch(std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << std::endl;
    file.close();
    std::cerr << "ERROR! File:" << argv[1] << std::endl;
    getchar();
    return EXIT_FAILURE;
  }

    file.close();
  std::cout << "SUCCESS! File:" << argv[1] << std::endl;
  //wfile << std::endl << "SUCCESS! File:" << argv[1] << std::endl;
  //wfile.close();
    return EXIT_SUCCESS;
}
